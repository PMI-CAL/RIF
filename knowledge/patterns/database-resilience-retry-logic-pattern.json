{
  "id": "database-resilience-retry-logic-pattern",
  "title": "Advanced Database Resilience with Intelligent Retry Logic Pattern",
  "category": "infrastructure",
  "complexity": "high",
  "description": "Comprehensive pattern for implementing sophisticated database retry logic, connection state management, transaction rollback handling, and deadlock resolution for enterprise-grade database resilience",
  "context": {
    "applies_to": ["database_connectivity", "connection_failures", "transaction_recovery", "deadlock_resolution", "system_resilience"],
    "triggers": ["connection_refused", "database_timeout", "deadlock_detected", "transaction_failure", "connection_pool_exhaustion"],
    "constraints": ["high_availability_requirements", "data_consistency", "performance_requirements", "concurrent_access"]
  },
  "pattern": {
    "problem": "Database connection failures can cause cascading system failures without proper retry logic, connection state management, transaction rollback handling, and deadlock resolution mechanisms",
    "solution": {
      "components": [
        {
          "name": "intelligent_retry_logic",
          "description": "Advanced retry mechanisms with exponential backoff, jitter, and circuit breaker patterns",
          "implementation": {
            "retry_policies": [
              {
                "type": "exponential_backoff",
                "description": "Configurable exponential backoff with jitter to prevent thundering herd",
                "parameters": {
                  "base_delay": "1.0s",
                  "max_delay": "30.0s", 
                  "backoff_multiplier": "2.0",
                  "jitter": "true",
                  "max_attempts": "3"
                }
              },
              {
                "type": "circuit_breaker",
                "description": "Circuit breaker pattern to prevent cascade failures",
                "parameters": {
                  "failure_threshold": "5 consecutive failures",
                  "recovery_timeout": "60.0s",
                  "success_threshold": "3 consecutive successes"
                }
              }
            ],
            "error_classification": {
              "retryable_errors": [
                "connection refused",
                "connection reset", 
                "timeout",
                "deadlock",
                "lock wait timeout",
                "connection lost",
                "database is locked",
                "disk i/o error"
              ],
              "non_retryable_errors": [
                "authentication failed",
                "permission denied",
                "syntax error",
                "constraint violation"
              ]
            }
          }
        },
        {
          "name": "connection_state_management",
          "description": "Sophisticated connection lifecycle management with real-time health monitoring",
          "implementation": {
            "connection_states": [
              "HEALTHY",
              "DEGRADED", 
              "FAILED",
              "RECOVERING",
              "SUSPENDED"
            ],
            "state_transitions": {
              "HEALTHY_to_DEGRADED": "2+ consecutive failures",
              "DEGRADED_to_FAILED": "5+ consecutive failures", 
              "FAILED_to_RECOVERING": "Recovery timeout expired",
              "RECOVERING_to_HEALTHY": "3+ consecutive successes",
              "any_to_SUSPENDED": "Manual intervention required"
            },
            "metrics_tracking": {
              "success_count": "Total successful operations",
              "failure_count": "Total failed operations",
              "consecutive_failures": "Current failure streak",
              "consecutive_successes": "Current success streak", 
              "avg_response_time": "Running average response time",
              "last_success": "Timestamp of last successful operation",
              "last_failure": "Timestamp of last failed operation"
            }
          }
        },
        {
          "name": "transaction_rollback_handling",
          "description": "Graceful transaction failure recovery with comprehensive rollback capabilities",
          "implementation": {
            "transaction_context": {
              "operation_tracking": "Records all operations within transaction",
              "rollback_generation": "Automatically generates compensating operations",
              "automatic_rollback": "Triggered on connection failures or exceptions",
              "isolation_levels": "Configurable transaction isolation"
            },
            "rollback_strategies": [
              {
                "type": "INSERT_rollback",
                "strategy": "Generate DELETE statement for inserted records"
              },
              {
                "type": "UPDATE_rollback", 
                "strategy": "Store original values for reversal operations"
              },
              {
                "type": "DELETE_rollback",
                "strategy": "Cache deleted records for potential restoration"
              }
            ]
          }
        },
        {
          "name": "deadlock_detection_resolution",
          "description": "Automatic deadlock detection and resolution with enhanced retry logic",
          "implementation": {
            "detection_mechanisms": {
              "background_monitoring": "Continuous deadlock detection thread",
              "transaction_registry": "Tracks all active transactions",
              "stale_transaction_detection": "Identifies long-running transactions",
              "resource_conflict_analysis": "Analyzes potential resource conflicts"
            },
            "resolution_strategies": {
              "deadlock_specific_retry": {
                "max_retries": "5 attempts",
                "retry_delay": "0.1s base with exponential backoff",
                "victim_selection": "Automatic deadlock victim selection"
              },
              "transaction_prioritization": "Priority-based deadlock resolution",
              "resource_ordering": "Consistent resource acquisition ordering"
            }
          }
        }
      ]
    },
    "benefits": [
      "Prevents cascading failures from database connection issues",
      "Provides automatic recovery from transient database failures",
      "Maintains data consistency through proper transaction rollback",
      "Resolves deadlocks automatically without manual intervention",
      "Comprehensive metrics for monitoring database health",
      "Configurable retry policies for different failure scenarios",
      "Circuit breaker prevents resource exhaustion during outages",
      "Backward compatibility with existing database code"
    ]
  },
  "implementation": {
    "languages": ["python"],
    "frameworks": ["duckdb", "database_connectivity"],
    "key_files": [
      "knowledge/database/retry_manager.py",
      "knowledge/database/resilient_connection_manager.py", 
      "knowledge/conversations/enhanced_storage_backend.py",
      "tests/test_database_resilience_issue152.py"
    ],
    "code_examples": {
      "retry_manager": {
        "python": "# Advanced retry manager with circuit breaker\nclass DatabaseRetryManager:\n    def __init__(self, config: RetryConfig):\n        self.config = config\n        self.connection_states = {}\n        self.circuit_breaker_state = ConnectionState.HEALTHY\n        self.deadlock_detector = DeadlockDetector()\n        \n    def execute_with_retry(self, operation, connection_id, operation_name):\n        for attempt in range(self.config.max_attempts):\n            try:\n                result = operation()\n                self.update_connection_metrics(connection_id, True)\n                return result\n            except Exception as e:\n                if not self.should_retry(attempt, e):\n                    break\n                delay = self.calculate_delay(attempt)\n                time.sleep(delay)\n        raise last_exception"
      },
      "connection_state_management": {
        "python": "# Connection state tracking with health metrics\n@dataclass\nclass ConnectionMetrics:\n    connection_id: str\n    state: ConnectionState\n    success_count: int = 0\n    failure_count: int = 0\n    consecutive_failures: int = 0\n    avg_response_time: float = 0.0\n    \n    def update_success(self, response_time: float):\n        self.success_count += 1\n        self.consecutive_successes += 1\n        self.consecutive_failures = 0\n        # Update running average\n        self.avg_response_time = (self.avg_response_time * 0.8) + (response_time * 0.2)"
      },
      "transaction_rollback": {
        "python": "# Transaction context with rollback capability\n@contextmanager\ndef transaction_context(self, connection, connection_id):\n    transaction_ctx = TransactionContext(\n        transaction_id=str(uuid.uuid4()),\n        connection_id=connection_id,\n        started_at=datetime.now()\n    )\n    \n    try:\n        connection.execute(\"BEGIN TRANSACTION\")\n        yield transaction_ctx\n        connection.execute(\"COMMIT\")\n        transaction_ctx.is_committed = True\n    except Exception as e:\n        connection.execute(\"ROLLBACK\")\n        transaction_ctx.is_rolled_back = True\n        raise"
      },
      "deadlock_resolution": {
        "python": "# Enhanced deadlock detection and resolution\ndef execute_with_deadlock_detection(self, operations, max_retries=3):\n    deadlock_attempt = 0\n    \n    while deadlock_attempt <= max_retries:\n        try:\n            return self.execute_transaction(operations)\n        except Exception as e:\n            if 'deadlock' in str(e).lower():\n                deadlock_attempt += 1\n                delay = self.retry_config.deadlock_retry_delay * (2 ** deadlock_attempt)\n                time.sleep(delay)\n                continue\n            raise"
      }
    }
  },
  "resilience_framework": {
    "retry_configurations": [
      {
        "use_case": "high_frequency_operations",
        "config": {
          "max_attempts": 2,
          "base_delay": 0.1,
          "max_delay": 5.0,
          "policy": "exponential_backoff"
        }
      },
      {
        "use_case": "critical_transactions",
        "config": {
          "max_attempts": 5,
          "base_delay": 1.0,
          "max_delay": 60.0,
          "policy": "exponential_backoff"
        }
      },
      {
        "use_case": "bulk_operations",
        "config": {
          "max_attempts": 3,
          "base_delay": 2.0,
          "max_delay": 30.0,
          "policy": "linear_backoff"
        }
      }
    ],
    "circuit_breaker_thresholds": {
      "failure_threshold": "5 consecutive failures opens circuit",
      "success_threshold": "3 consecutive successes closes circuit",
      "recovery_timeout": "60s before attempting recovery",
      "half_open_success_rate": "80% required to fully close"
    }
  },
  "validation": {
    "test_scenarios": [
      {
        "name": "connection_refused_recovery",
        "scenario": "Database refuses connections, retry logic should recover",
        "expected": "Successful recovery within configured retry attempts",
        "metrics": "Retry success rate >95%"
      },
      {
        "name": "transaction_rollback_integrity",
        "scenario": "Connection failure during transaction should rollback cleanly",
        "expected": "Complete transaction rollback with data integrity maintained", 
        "metrics": "100% rollback success rate"
      },
      {
        "name": "deadlock_resolution_performance",
        "scenario": "Multiple concurrent transactions causing deadlocks",
        "expected": "Automatic deadlock resolution with minimal delay",
        "metrics": "Recovery time <10s, resolution success >90%"
      },
      {
        "name": "circuit_breaker_protection",
        "scenario": "Database completely unavailable, circuit should open",
        "expected": "Circuit breaker opens after threshold, prevents resource exhaustion",
        "metrics": "Circuit opens within 5 failures, recovers automatically"
      }
    ],
    "performance_benchmarks": {
      "retry_overhead": "<2% performance impact during normal operations",
      "recovery_time": "<10s average for transient failures",
      "throughput_degradation": "<5% during retry scenarios",
      "memory_overhead": "<100MB for connection state tracking"
    }
  },
  "lessons_learned": [
    "Exponential backoff with jitter is critical to prevent thundering herd problems",
    "Connection state management prevents cascading failures across system components",
    "Transaction rollback handling ensures data integrity during connection failures", 
    "Deadlock detection and resolution patterns enable high-concurrency database operations",
    "Circuit breaker patterns protect against resource exhaustion during outages",
    "Comprehensive metrics are essential for monitoring database resilience effectiveness",
    "Backward compatibility allows gradual adoption of resilience features",
    "Configuration flexibility enables tuning for different application requirements",
    "Error classification prevents unnecessary retries on permanent failures",
    "Health monitoring enables proactive intervention before complete failures"
  ],
  "integration_patterns": [
    {
      "name": "optional_enhancement_pattern",
      "description": "Allows existing systems to optionally enable resilience features",
      "implementation": "use_resilient_manager=True parameter for backward compatibility"
    },
    {
      "name": "health_monitoring_integration",
      "description": "Provides metrics for system monitoring and alerting",
      "implementation": "get_connection_health() API for dashboard integration"
    },
    {
      "name": "configuration_driven_behavior",
      "description": "All retry parameters configurable for different environments",
      "implementation": "RetryConfig dataclass with environment-specific settings"
    }
  ],
  "related_patterns": [
    "database-authentication-diagnostic-pattern",
    "connection-pool-management-pattern", 
    "circuit-breaker-pattern",
    "transaction-management-pattern",
    "health-monitoring-pattern"
  ],
  "source": {
    "issue": "#152",
    "error_id": "err_20250824_c5803a10",
    "date": "2025-08-24", 
    "agent": "RIF-Learner",
    "session": "database-resilience-learning-extraction"
  }
}