{
  "pattern_id": "claude-code-orchestration-reality-pattern",
  "name": "Claude Code Orchestration Reality Pattern",
  "category": "architecture",
  "confidence": 0.95,
  "created_date": "2025-08-24",
  "source_issue": "#98",
  "description": "Defines the correct understanding of how Claude Code operates as an orchestrator, not as an orchestrated system",
  
  "problem": {
    "description": "Fundamental misunderstanding of Claude Code's operational model led to 37 incompatible implementations across RIF system",
    "symptoms": [
      "Issues attempting to launch Claude Code as external Task",
      "Systems assuming persistent background processes",
      "External orchestration attempts of Claude Code sessions",
      "Inter-session state dependencies"
    ],
    "impact": "40.2% of all RIF issues (37 of 92) were fundamentally incompatible with Claude Code's capabilities"
  },

  "solution": {
    "principle": "Claude Code IS the orchestrator, never orchestrated by external systems",
    "correct_patterns": [
      {
        "pattern": "Claude Code directly launches multiple Task agents in single response",
        "example": "Task(description='RIF-Analyst for #3', prompt='You are RIF-Analyst...')\nTask(description='RIF-Implementer for #2', prompt='You are RIF-Implementer...')"
      },
      {
        "pattern": "Tasks run in parallel when launched together",
        "example": "Multiple Task() calls in one Claude response = parallel execution"
      },
      {
        "pattern": "Session-scoped operation with file-based persistence",
        "example": "Use GitHub issues, labels, and file storage for state persistence"
      },
      {
        "pattern": "Event-triggered hooks, not continuous monitoring",
        "example": "UserPromptSubmit, PostToolUse hooks trigger actions, no background processes"
      }
    ]
  },

  "anti_patterns": [
    {
      "anti_pattern": "Launching Claude Code as external Task",
      "why_wrong": "Claude Code cannot launch itself - it IS the launcher",
      "correct_alternative": "Claude Code launches specialized Task agents"
    },
    {
      "anti_pattern": "Persistent background processes monitoring Claude Code",
      "why_wrong": "Claude Code operates in sessions, no continuous processes",
      "correct_alternative": "Event-triggered hooks with file-based results"
    },
    {
      "anti_pattern": "External systems orchestrating Claude Code",
      "why_wrong": "Claude Code is the orchestrator, not orchestrated",
      "correct_alternative": "Claude Code orchestrates other systems via API calls"
    },
    {
      "anti_pattern": "Inter-session state dependencies",
      "why_wrong": "Each Claude Code session is independent",
      "correct_alternative": "Use GitHub issues/labels and files for persistence"
    }
  ],

  "implementation_guidelines": [
    "Always design Claude Code as the central orchestrator",
    "Use Task() tool for launching specialized agents",
    "Implement persistence through files and GitHub state",
    "Use hooks for event-triggered automation",
    "Design for session-scoped operations",
    "Avoid assumptions about continuous processes"
  ],

  "validation_criteria": [
    "System works within single Claude Code session",
    "No external systems attempt to orchestrate Claude Code",
    "State persistence uses files/GitHub, not session memory",
    "All background work uses event-triggered hooks"
  ],

  "evidence": {
    "source_issues": ["#98", "#2", "#4", "#51-59", "#81-86", "#88"],
    "failure_examples": [
      "Issue #2: Attempted to launch Claude Code as Task",
      "Issues #51-59: External orchestration systems",
      "Issues #81-86: Background monitoring systems",
      "Issue #88: Inter-session state management"
    ],
    "success_examples": [
      "Issue #97: MCP server integration via session tools",
      "Issues #45-50: Hook-based conversation capture",
      "Issue #51: Dynamic orchestration with Claude as orchestrator"
    ]
  },

  "metrics": {
    "compatibility_failures": {
      "total_issues": 92,
      "incompatible": 37,
      "failure_rate": "40.2%"
    },
    "pattern_application": {
      "fixed_issues": 5,
      "prevention_rate": "100% with MCP validation",
      "implementation_success": "95%"
    }
  },

  "related_patterns": [
    "mcp-integration-pattern",
    "event-driven-hooks-pattern", 
    "task-orchestration-pattern",
    "session-scoped-persistence-pattern"
  ],

  "lessons_learned": [
    "Compatibility validation must happen at design phase",
    "Architecture assumptions must be validated against actual capabilities",
    "Prevention is more effective than remediation",
    "Clear documentation of operational model prevents misunderstanding"
  ]
}