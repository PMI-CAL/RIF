-- VSS Extension Setup for DuckDB Knowledge Graph
-- Issue #28: Implement DuckDB schema for knowledge graph
-- Vector Similarity Search Configuration
-- Generated by: RIF-Implementer
-- Date: 2025-08-23

-- =============================================================================
-- VSS EXTENSION SETUP
-- =============================================================================

-- Install and load VSS extension for vector similarity search
INSTALL vss;
LOAD vss;

-- Verify VSS extension is loaded
SELECT extension_name, loaded, installed 
FROM duckdb_extensions() 
WHERE extension_name = 'vss';

-- =============================================================================
-- VECTOR SIMILARITY INDEXES
-- =============================================================================

-- Create vector similarity indexes for entity embeddings
CREATE INDEX IF NOT EXISTS idx_entities_embedding 
ON entities USING HNSW (embedding) 
WITH (metric = 'cosine');

-- Create vector similarity index for agent memory embeddings  
CREATE INDEX IF NOT EXISTS idx_agent_memory_embedding 
ON agent_memory USING HNSW (embedding)
WITH (metric = 'cosine');

-- =============================================================================
-- VECTOR SIMILARITY FUNCTIONS
-- =============================================================================

-- Function to find similar entities by embedding
CREATE OR REPLACE FUNCTION find_similar_entities(query_embedding FLOAT[768], limit_count INTEGER DEFAULT 10)
RETURNS TABLE(
    id UUID,
    name VARCHAR(255),
    type VARCHAR(50),
    file_path VARCHAR(500),
    similarity_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.name,
        e.type,
        e.file_path,
        1.0 - cosine_distance(e.embedding, query_embedding) AS similarity_score
    FROM entities e
    WHERE e.embedding IS NOT NULL
    ORDER BY cosine_distance(e.embedding, query_embedding) ASC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- Function to find similar agent memories
CREATE OR REPLACE FUNCTION find_similar_agent_memories(query_embedding FLOAT[768], agent_type_filter VARCHAR(50) DEFAULT NULL, limit_count INTEGER DEFAULT 10)
RETURNS TABLE(
    id UUID,
    agent_type VARCHAR(50),
    issue_number INTEGER,
    context TEXT,
    decision TEXT,
    outcome VARCHAR(50),
    similarity_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        am.id,
        am.agent_type,
        am.issue_number,
        am.context,
        am.decision,
        am.outcome,
        1.0 - cosine_distance(am.embedding, query_embedding) AS similarity_score
    FROM agent_memory am
    WHERE am.embedding IS NOT NULL
      AND (agent_type_filter IS NULL OR am.agent_type = agent_type_filter)
    ORDER BY cosine_distance(am.embedding, query_embedding) ASC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- Function for hybrid search (text + vector)
CREATE OR REPLACE FUNCTION hybrid_entity_search(
    query_text VARCHAR(255), 
    query_embedding FLOAT[768] DEFAULT NULL,
    entity_type_filter VARCHAR(50) DEFAULT NULL,
    limit_count INTEGER DEFAULT 10
)
RETURNS TABLE(
    id UUID,
    name VARCHAR(255),
    type VARCHAR(50),
    file_path VARCHAR(500),
    text_relevance FLOAT,
    vector_similarity FLOAT,
    combined_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.name,
        e.type,
        e.file_path,
        -- Text relevance using full-text search
        CASE 
            WHEN e.name ILIKE '%' || query_text || '%' THEN 1.0
            WHEN e.file_path ILIKE '%' || query_text || '%' THEN 0.7
            WHEN e.metadata::TEXT ILIKE '%' || query_text || '%' THEN 0.5
            ELSE 0.0
        END AS text_relevance,
        -- Vector similarity (if embedding provided)
        CASE 
            WHEN query_embedding IS NOT NULL AND e.embedding IS NOT NULL 
            THEN 1.0 - cosine_distance(e.embedding, query_embedding)
            ELSE 0.0
        END AS vector_similarity,
        -- Combined score (weighted average)
        CASE 
            WHEN query_embedding IS NOT NULL AND e.embedding IS NOT NULL 
            THEN (
                CASE 
                    WHEN e.name ILIKE '%' || query_text || '%' THEN 1.0
                    WHEN e.file_path ILIKE '%' || query_text || '%' THEN 0.7
                    WHEN e.metadata::TEXT ILIKE '%' || query_text || '%' THEN 0.5
                    ELSE 0.0
                END * 0.3 + 
                (1.0 - cosine_distance(e.embedding, query_embedding)) * 0.7
            )
            ELSE CASE 
                    WHEN e.name ILIKE '%' || query_text || '%' THEN 1.0
                    WHEN e.file_path ILIKE '%' || query_text || '%' THEN 0.7
                    WHEN e.metadata::TEXT ILIKE '%' || query_text || '%' THEN 0.5
                    ELSE 0.0
                END
        END AS combined_score
    FROM entities e
    WHERE (entity_type_filter IS NULL OR e.type = entity_type_filter)
      AND (
          e.name ILIKE '%' || query_text || '%' 
          OR e.file_path ILIKE '%' || query_text || '%'
          OR e.metadata::TEXT ILIKE '%' || query_text || '%'
          OR (query_embedding IS NOT NULL AND e.embedding IS NOT NULL)
      )
    ORDER BY combined_score DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- VECTOR OPERATIONS UTILITIES
-- =============================================================================

-- Function to calculate embedding statistics
CREATE OR REPLACE FUNCTION embedding_statistics()
RETURNS TABLE(
    table_name VARCHAR(50),
    total_records INTEGER,
    records_with_embeddings INTEGER,
    embedding_coverage_percent FLOAT,
    avg_embedding_magnitude FLOAT
) AS $$
BEGIN
    -- Entity embeddings statistics
    RETURN QUERY
    SELECT 
        'entities'::VARCHAR(50),
        COUNT(*)::INTEGER AS total_records,
        COUNT(embedding)::INTEGER AS records_with_embeddings,
        (COUNT(embedding) * 100.0 / COUNT(*))::FLOAT AS embedding_coverage_percent,
        AVG(array_dot(embedding, embedding))::FLOAT AS avg_embedding_magnitude
    FROM entities;
    
    -- Agent memory embeddings statistics
    RETURN QUERY
    SELECT 
        'agent_memory'::VARCHAR(50),
        COUNT(*)::INTEGER AS total_records,
        COUNT(embedding)::INTEGER AS records_with_embeddings,
        (COUNT(embedding) * 100.0 / COUNT(*))::FLOAT AS embedding_coverage_percent,
        AVG(array_dot(embedding, embedding))::FLOAT AS avg_embedding_magnitude
    FROM agent_memory;
END;
$$ LANGUAGE plpgsql;

-- Function to validate embedding dimensions
CREATE OR REPLACE FUNCTION validate_embedding_dimensions()
RETURNS TABLE(
    table_name VARCHAR(50),
    record_id UUID,
    embedding_length INTEGER,
    is_valid_dimension BOOLEAN
) AS $$
BEGIN
    -- Check entity embeddings
    RETURN QUERY
    SELECT 
        'entities'::VARCHAR(50),
        id,
        array_length(embedding, 1)::INTEGER,
        (array_length(embedding, 1) = 768)::BOOLEAN
    FROM entities 
    WHERE embedding IS NOT NULL
      AND array_length(embedding, 1) != 768;
    
    -- Check agent memory embeddings  
    RETURN QUERY
    SELECT 
        'agent_memory'::VARCHAR(50),
        id,
        array_length(embedding, 1)::INTEGER,
        (array_length(embedding, 1) = 768)::BOOLEAN
    FROM agent_memory 
    WHERE embedding IS NOT NULL
      AND array_length(embedding, 1) != 768;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- VSS INDEX MAINTENANCE
-- =============================================================================

-- Function to rebuild VSS indexes (for maintenance)
CREATE OR REPLACE FUNCTION rebuild_vss_indexes()
RETURNS TEXT AS $$
BEGIN
    -- Drop existing VSS indexes
    DROP INDEX IF EXISTS idx_entities_embedding;
    DROP INDEX IF EXISTS idx_agent_memory_embedding;
    
    -- Recreate VSS indexes
    CREATE INDEX idx_entities_embedding 
    ON entities USING HNSW (embedding) 
    WITH (metric = 'cosine');
    
    CREATE INDEX idx_agent_memory_embedding 
    ON agent_memory USING HNSW (embedding)
    WITH (metric = 'cosine');
    
    RETURN 'VSS indexes rebuilt successfully';
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- PERFORMANCE TESTING QUERIES
-- =============================================================================

-- Test vector similarity search performance
CREATE OR REPLACE FUNCTION test_vss_performance(test_embedding FLOAT[768] DEFAULT NULL)
RETURNS TABLE(
    test_type VARCHAR(50),
    execution_time_ms INTEGER,
    results_count INTEGER,
    status VARCHAR(20)
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    duration_ms INTEGER;
    test_vector FLOAT[768];
BEGIN
    -- Generate random test vector if none provided
    IF test_embedding IS NULL THEN
        SELECT ARRAY(SELECT random() FROM generate_series(1, 768)) INTO test_vector;
    ELSE
        test_vector := test_embedding;
    END IF;
    
    -- Test entity similarity search
    start_time := clock_timestamp();
    DROP TABLE IF EXISTS temp_entity_results;
    CREATE TEMP TABLE temp_entity_results AS
    SELECT * FROM find_similar_entities(test_vector, 100);
    end_time := clock_timestamp();
    
    duration_ms := EXTRACT(epoch FROM (end_time - start_time)) * 1000;
    
    RETURN QUERY
    SELECT 
        'Entity Similarity Search'::VARCHAR(50),
        duration_ms::INTEGER,
        (SELECT COUNT(*)::INTEGER FROM temp_entity_results),
        CASE WHEN duration_ms < 100 THEN 'EXCELLENT' 
             WHEN duration_ms < 500 THEN 'GOOD'
             WHEN duration_ms < 1000 THEN 'ACCEPTABLE'
             ELSE 'SLOW' END::VARCHAR(20);
    
    -- Test agent memory similarity search
    start_time := clock_timestamp();
    DROP TABLE IF EXISTS temp_memory_results;
    CREATE TEMP TABLE temp_memory_results AS
    SELECT * FROM find_similar_agent_memories(test_vector, NULL, 50);
    end_time := clock_timestamp();
    
    duration_ms := EXTRACT(epoch FROM (end_time - start_time)) * 1000;
    
    RETURN QUERY
    SELECT 
        'Agent Memory Search'::VARCHAR(50),
        duration_ms::INTEGER,
        (SELECT COUNT(*)::INTEGER FROM temp_memory_results),
        CASE WHEN duration_ms < 100 THEN 'EXCELLENT' 
             WHEN duration_ms < 500 THEN 'GOOD'
             WHEN duration_ms < 1000 THEN 'ACCEPTABLE'
             ELSE 'SLOW' END::VARCHAR(20);
             
    -- Cleanup
    DROP TABLE IF EXISTS temp_entity_results;
    DROP TABLE IF EXISTS temp_memory_results;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- VSS SETUP VALIDATION
-- =============================================================================

-- Verify VSS setup is complete
SELECT 
    'VSS Extension Setup Complete' AS status,
    COUNT(*) AS vss_indexes_created
FROM information_schema.indexes 
WHERE index_name LIKE '%embedding';

-- Display available vector functions
SELECT 
    'Available Vector Functions:' AS info,
    routine_name,
    routine_type
FROM information_schema.routines 
WHERE routine_name IN (
    'find_similar_entities',
    'find_similar_agent_memories', 
    'hybrid_entity_search',
    'embedding_statistics',
    'validate_embedding_dimensions',
    'rebuild_vss_indexes',
    'test_vss_performance'
);

-- =============================================================================
-- END VSS SETUP
-- =============================================================================